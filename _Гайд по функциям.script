Данный гайд предполагает, что вы владеете базовыми навыками модостроя и примерно понимаете, что нужно делать и служит лищь шпаргалкой. 

ДЛЯ РАБОТЫ БОЛЬШИНСТВА ФУНКЦИЙ НУЖЕН sak.script из СБОРНИКА, поэтому кидаем его в свою папку gamedata\scripts\
--------------------------------------------------------------------------------------------------------------
файлы с функциями(скрипты) создаются своими руками в папке gamedata\scripts и называются "имя_файла.script", нигде больше их регать не надо.
Следите за тем, что пишете в скриптах, произвольные символы вызывают вылет, свои комментарии оставляем так:
-- мой коммент

Для начала давайте разберем функции, то как они выглядят:

function имя_функции ()
	тело_функции
end

тело_функции - часто можно в этом месте встретить нечто вроде:
dialogs.relocate_item_section(db.actor, "wpn_pm", "in")

relocate_item_section это функция из dialogs.script , а (db.actor, "wpn_pm", "in") это аргументы этой функции

то есть, если вы откроете dialogs.script и найдёте функцию relocate_item_section, то увидите:
function relocate_item_section(victim, section, type)

и вместо (victim, section, type) мы при вызове указали (db.actor, "wpn_pm", "in")


Не у всех функций есть аргументы, но иногда в диалоге от них зависит кто получает вещь, а кто отдает.

Закрепим, что функции внути функции вызывются так:

function имя_функции ()
	имя_файла.функция()
end

так приходится делать, потому что диалоги например не могут читать аргументы, а для использования аргументов в логике придётся писать функции по особенному.

также стоит учесть, что во многих функциях и методах стоит проверять наличие актора:
function имя_функции ()
	if db.actor then
		...
	end
end

так как может случится вылет если актора не будет

--------------------------------------------------------------------------------------------------------------
В диалогах функции вызываются так:
    <phrase id="121">
        <text>tutorial_wounded_give_medkit_121</text>
        <action>dialogs.transfer_medkit</action> 
    </phrase>
	
	в инфопоршях:
	<info_portion id="escape_stalker_meet">
		<action>dialogs.transfer_medkit</action>
	</info_portion>

Но в инфо лучше не злоупотреблять, а то вылеты непонятны.

где, dialogs это dialogs.script, а transfer_medkit это функция из этого скрипта
--------------------------------------------------------------------------------------------------------------
Так же в диалогах можно использовать функции проверки <precondition>, для того, чтобы некоторые фразы отображались, если соблюдены условия функции 

            <phrase id="2">
                <text>tutorial_wounded_give_medkit_2</text>
                <precondition>dialogs.actor_have_medkit</precondition>
                <next>121</next>
            </phrase>
			
В данном примере диалог не выйдет на 2 фразу, пока не будет выполнено условие из <precondition>dialogs.actor_have_medkit</precondition>
--------------------------------------------------------------------------------------------------------------
Прекондишны можно ставить и на сам диалог, чтобы задать условие его появления.

    <dialog id="escape_trader_talk_level" priority="2">
        <precondition>escape_dialog.trader_alredy_give_job</precondition>
        <phrase_list>
			
--------------------------------------------------------------------------------------------------------------            
В квестах функции проверки выглядят так <function_complete>sak.prov</function_complete>
		<objective>
			<text>name_pod_kvest_1</text>
			<function_complete>sak.prov</function_complete>
		</objective>
--------------------------------------------------------------------------------------------------------------            
Сами функции проверки выглядят так:

function название_функции()
	if "набор условий" then
		return true
	end
	return false
end

"набор условий" это нечто вроде if has_alife_info("инфопоршн1") and not has_alife_info("инфопоршн2") then  что означает, если получен "инфопоршн1" и не получен "инфопоршн2", то истина
или if sak.have_item_namber("af_medusa",1) and sak.have_item_namber("wpn_pm",1) then что означает, если получен 1 "af_medusa" и 1 получен "wpn_pm", то истина
--------------------------------------------------------------------------------------------------------------
тут идет проверка на наличие и отсутствие определенных инфо, если одно из условий выполнено проверка пройдёт, а при отсутствии нет

function trader_alredy_give_job()
	if (has_alife_info("agroprom_military_case") and not has_alife_info("agroprom_military_case_done")) or
	   (has_alife_info("escape_blockpost_case") and not has_alife_info("escape_blockpost_case_done")) or
	   (has_alife_info("tutorial_artefact_start") and not has_alife_info("tutorial_artefact_done")) or
	   (has_alife_info("tutorial_wounded_start") and not has_alife_info("esc_serious_talk"))
	then
		return true
	end
	return false
end
--------------------------------------------------------------------------------------------------------------
Можно сделать более простую проверку на предмет af_medusa и также использовать в прекондишене
--------------------------------------------------------------------------------------------------------------
function prov() 
	return sak.have_item_namber("af_medusa",1) ~= false
end
--------------------------------------------------------------------------------------------------------------
Можно сделать проверку, если есть инфо "storyline_actor_start" и нет инфо "when_out_kordon", то будет выдан инфо "infoportion_xxx"
function prov_info2()
	if has_alife_info("storyline_actor_start") and not has_alife_info("when_out_kordon") then
		db.actor:give_info_portion("infoportion_xxx")
	end 
end
--------------------------------------------------------------------------------------------------------------
ВЫПОЛНЕНИЕ ФУНКЦИИ ПРИ ПОПАДАНИИ ПРЕДМЕТА В ИНВЕНТАРЬ(в данном случае при подборе с земли аптечки на будут выданы предметы, ниже привел пример для ваших проверок)

в \gamedata\scripts\bind_stalker.script
в function actor_binder:on_item_take (obj)
добавляем строку
sak.take_item(obj)

в вашем файле sak.script

function take_item(obj)
local obj_sect = obj:section()

	if obj_sect == "medkit" then
		dialogs.relocate_item_section(db.actor, "wpn_bm16", "in")	
	end
	-- if obj_sect == "ваш_предмет" then
		--ваше действие
	-- end
end
--------------------------------------------------------------------------------------------------------------
ВЫПОЛНЕНИЕ ФУНКЦИИ ПРИ ИСПОЛЬЗОВАНИИ ПРЕДМЕТА В ИНВЕНТАРЕ
1.В ФАЙЛЕ "bind_stalker.script" в функции 
function actor_binder:net_destroy() 

после self.object:set_callback(callback.take_item_from_box, nil)
вставляем  self.object:set_callback(callback.use_object, nil)

2.далее в 
function actor_binder:reinit()
после self.object:set_callback(callback.take_item_from_box, self.take_item_from_box, self)
вставляем self.object:set_callback(callback.use_object, self.use_object, self)

между функциями вставляем 
function actor_binder:use_object(obj)
	sak.use_item(obj)
end

в вашем файле sak.script

function use_item(obj)
local obj_sect = obj:section()

	if obj_sect == "medkit" then
		dialogs.relocate_item_section(db.actor, "wpn_bm16", "in")	
	end
	-- if obj_sect == "ваш_предмет" then
		--ваше действие
	-- end
end
--------------------------------------------------------------------------------------------------------------
ПРОВЕРКА НА НАЖАТИЕ КЛАВИШ
1.В ФАЙЛЕ "bind_stalker.script" в функции 
function actor_binder:net_destroy()

	self.object:set_callback(callback.on_key_press, self.on_key, self)
	
2.далее в 
function actor_binder:reinit()

	self.object:set_callback(callback.on_key_press, self.on_key, self)
	
3.ниже

function actor_binder:on_key(key, bind)
	self.object:call("on_key", key, bind)
end
----------------------------------------------------------------------------------------------------------------------
function actor_binder:on_key(key)
	if key == DIK_keys.DIK_V then
	if noclip_mode.noclip_active == true then
		noclip_mode.noclip_active = false
	else
		noclip_mode.noclip_active = true
	end
	end
	
	if key == DIK_keys.DIK_NUMPAD1 then
	if noclip_mode.delay_time > 0 then
		noclip_mode.delay_time = noclip_mode.delay_time - 5
		db.actor:give_game_news(string.format("Задержка = %G.. миллисекунд", noclip_mode.delay_time), "ui\\ui_iconsTotal",Frect():set(663,554,194,102), 0, 1000)
	end
	end
	
	if key == DIK_keys.DIK_NUMPAD2 then
	noclip_mode.delay_time	= noclip_mode.delay_time + 5
	db.actor:give_game_news(string.format("Задержка = %G.. миллисекунд", noclip_mode.delay_time), "ui\\ui_iconsTotal",Frect():set(663,554,194,102), 0, 1000)
	end
	
end
--------------------------------------------------------------------------------------------------------------
Для оригинала ТЧ: https://vk.com/@-226619903-testovaya-statya

файлы
https://drive.google.com/drive/folders/1UzgB239SlfY52QzXmvNgR3hH1DUmRkZq


--------------------------------------------------------------------------------------------------------------
Также функции можно вызывать через логику
--------------------------------------------------------------------------------------------------------------

Вызов функции:
%=название_функции%

Проверка функции:
{=название_функции}

Пример:

[logic]
active = sr_idle1

[sr_idle1]
on_timer = 10000 | %=название_функции% sr_idle

Функции проверки должны лежать в \gamedata\scripts\xr_conditions.script

Функции типа %=% должны лежать в \gamedata\scripts\xr_effects.script




--------------------------------------------------------------------------------------------------------------
ДЛЯ БЫСТРОГО ТЕСТА ФУНКЦИЙ ИСПОЛЬЗУЕМ bind_stalker.script
--------------------------------------------------------------------------------------------------------------


находим if self.bCheckStart then
и строкой ниже printf("SET DEFAULT INFOS")
вставляем например выдачу инфо  db.actor:give_info_portion("tutorial_artefact_start")
Это будет работать при начале новой игры, после каждой перезагрузки уровня\перехода на локацию.
--------------------------------------------------------------------------------------------------------------
Чтобы сделать запуск функции один раз при начале игры нужно вставить её в if not has_alife_info("global_dialogs") then чтобы получилось так
if not has_alife_info("global_dialogs") then
	db.actor:give_info_portion("tutorial_artefact_start") -- ваше действие
	self.object:give_info_portion("global_dialogs")
end
--------------------------------------------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------------
ПОСТАВИТЬ Функции НА ПОСТОЯННУЮ ПРОВЕРКУ МОЖНО ЧЕРЕЗ:
--------------------------------------------------------------------------------------------------------------


В function proceed() в файле \gamedata\scripts\escape_tasks.script
там запущена постоянная проверка на соблюдение условий, полезно, когда нужно чтобы условие проверялось вне квеств и диалога.
Начало файла: 
function proceed()
 вставляем
	if	not has_alife_info("tutorial_artefact_start") and sak.have_item_namber("af_medusa",1)
	then		
		db.actor:give_info_portion("tutorial_artefact_start")
	end

Разбираем: проверка будет работать пока не получен инфо "tutorial_artefact_start", так как после попадания в инвентарь "af_medusa" будет выдан инфо "tutorial_artefact_start" тем самым завершит проверку.

Свои проверки так же начинаем с if и заканчиваем end, оформляем по принципу:
	if "набор условий" and not has_alife_info("инфопоршн1") then
		-- ваше действие
		db.actor:give_info_portion("инфопоршн1")
	end

"набор условий" это нечто вроде if has_alife_info("инфопоршн1") and not has_alife_info("инфопоршн2") then

то есть, если выполнено условие и не получен инфо, то выдаем этот инфо чтобы закрыть проверку, если так не сделать, то "ваше действие" будет выполнятся бесконечно, такой проблемы лишены квесты и прекондишены в диалогах, ведь там если истина, то сразу функция выключается
--------------------------------------------------------------------------------------------------------------


НО там же есть функция process_info_portion(info_id) 
Вот пример
 elseif info_id == "esc_tutorial_secret_place_found" then 
  level_tasks.remove_location(025, "green_location")

Это значит, что при получении инфо "esc_tutorial_secret_place_found" будет выполнено действие, и как можете заметить никакого более условия нет и не нужно.
--------------------------------------------------------------------------------------------------------------


Помимо "escape_tasks.script" можно использовать и "\gamedata\scripts\bind_stalker.script"

находим function actor_binder:update(delta)
и после строки 	object_binder.update(self, delta)
вставляем имя_вашего_файла.имя_функции()

например это будет sak.script и функция main
получилось:
function actor_binder:update(delta)
	object_binder.update(self, delta)
	sak.main()

функцию main оформляем как и function proceed() из файла \gamedata\scripts\escape_tasks.script

function main()
	if sak.have_item_namber("af_medusa",1) and not has_alife_info("tutorial_artefact_start") then		
		db.actor:give_info_portion("tutorial_artefact_start")
	end
end
--------------------------------------------------------------------------------------------------------------




--------------------------------------------------------------------------------------------------------------
СПОСОБЫ ВЗАИМОДЕЙСТВИЯ С НПС И ПРОЧИМИ ОБЪЕКТАМИ
--------------------------------------------------------------------------------------------------------------


Для начала определим локальную переменную obj - это будет клиентский объект, с ней будем взаимодействовать через клиентские методы, под взаимодействием понимается примерно следующее:

obj:set_money( 65000 ) установить количество денег 
obj:set_character_rank(1000) установить ранг
Эти два метода были добавлены в ОГСР

Так вот эти методы работают только  для клиентских объектов, но есть ещё и серверные методы...

Че это вообще? 💀 Это короче разрабы в движке сделали разные методы, которые работают либо для sobj(серверный объект), либо для obj(клиентский объект), то есть нашли вы какой-то метод, типа нпс денег прибавить, а он оказывается клиентский, вот смотрим ниже как obj получать.
Для начала определим серверный объект
-- Серверный объект Нпс Волк sobj
local sobj = alife():object("esc_wolf")
-- или по стори айди
local sobj = alife():story_object( 6 ) 

-- Клиентский объект obj
указывать нужно конкретный айди, получать его можно способами ниже
local obj = level.object_by_id(15787)
--Но в тоже время если у нпс есть стори айди и нам нужен клиентский метод, то:
local obj = level_object_by_sid( 6 )

А теперь получаем клиентский из серверного, obj из sobj

это значит в игре есть нпс у которого name в all.spawn "esc_wolf", указывается короче нейм и всё дальше obj используем во всех клиентских методах
local sobj = alife():object("esc_wolf") -- Серверный объект
local obj = level.object_by_id(sobj.id) -- Клиентский объект

можно ещё по стори айди

local sobj = alife():story_object(6) -- Серверный объект
local obj = level.object_by_id(sobj.id) -- Клиентский объект

Вот, например, пару примеров клиентских методов:
--установка отношений
obj:set_relation(game_object.friend, db.actor)

--и новые из огср
obj:set_money( 65000 )
obj:set_character_rank(1000)
obj:set_npc_position(vector():set(-152.0,-18.0,-144.3),98126,45)

Только прошу заметить, что так:
local sobj = alife():object("esc_wolf") -- Серверный объект
не получится определить нпс, заспавненого через скрипт, для них используется универсальный вариант и для клиента и сервера. Тоже перебор по имени только sapwn_section теперь учитывается
function perebor() 
	for a=1,65635,1 do 
	local obj=level.object_by_id(a) 
		if obj and string.find(obj:name(),"esc_wolf") then 
			-- действие, например, убить этого нпс:
			obj:kill(obj)
		end 
	end 
end

Теперь наоборот получаем серверный через клиентский

это может быть функция перебора имен, показанная выше или определение по стори айди для клиента.

Клиентский объект это его айди, типа 16575, но тут надо понимать что заранее он не известен, поэтому смысл в том чтобы через диалог или логику делать так:
--тут предполагается, что npc будет передан через диалог, например это тот с кем говорим или в скриптах как-нибудь.
local obj = level.object_by_id(npc)
local sobj = alife():object( obj:id() )

--либо делать как в примере ниже
local sobj = obj and alife():object(obj:id())
--тут предполагается, что айди'шка передастся сразу, без доп усилий.

и действие  например:
--удалить:
alife():release(sobj)

--увести в оффлайн:
alife():set_switch_online(sobj.id, false) 
alife():set_switch_offline(sobj.id, true)

--поставить метку
level.map_add_object_spot(sobj.id, "green_location", "текст")

Вот яркий пример использования серверного метода через клиентский объект и как вызов из логики без дополнительных данных.
Через логику иначе и не выйдет, ведь она передает только клиентский объект.
если в xr_effects.script
добавить 

function remove_object(actor, obj)
local sobj = obj and alife():object(obj:id())
  if sobj then
    alife():release(sobj)
  end
end

то в рестрикторе или где угодно можно сделать вызов и объект удалится
on_actor_outside = nil %=remove_object%

Теперь рассмотрим момент использования клиентских методов через логику/диалог
в xr_effects.script
добавить 

function kill_object(actor, obj)
  if obj then
    obj:kill(obj)
  end
end

--а в логике нпс/диалоге сделать вызов и объект должен погибнуть, вызов:
on_info = {±инфо} %=kill_object%
--или в диалоге, но учитывайте что нужно ставить на фразу, которую говорит гг
<action>xr_effects.kill_object</action>
как видите с клиентским методом никак определять obj не пришлось, ведь он и представляет из себя айди.
