Все видео про схемы: https://www.youtube.com/playlist?list=PLONawgtVvphyyuWnO5sQO_iKcBEUqNFT0

Разбор всех схем: 	 https://sites.google.com/view/stsocmoding/%D0%BA%D0%B0%D1%82%D0%B5%D0%B3%D0%BE%D1%80%D0%B8%D1%8F%D1%81%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D1%8B-stalkerin-gameru-net/%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%BB%D0%BE%D0%B3%D0%B8%D0%BA%D0%B8-%D1%87%D0%B0%D1%81%D1%82%D1%8C-0



Любая схема начинается с:
[logic]
active = активная схема

Для нпс можно сделать заглушку active = nil, если нпс не нужна логика того же волкера, но обязательно нужна схема "death",
НО в гулаге так нельзя, вылет: gulag: ltx=%s, there is no path in section %s


Логику можно писать как в сдк так и вынести в отдельный файл по пути \gamedata\config\
[logic]
cfg = scripts\sar_monolith.ltx

Давайте разберем все возможные активные схемы:

----------------------------------------------------------------------
Схемы для нпс:
----------------------------------------------------------------------
"walker" 		Это базовая схема, по которой персонаж, перемещается по патрульному пути (path_walk) и останавливается в определенных точках и выполняет соответствующие действия

"remark" 		Схема используется для синхронизации\связки других схем, её задача запускать анимации и озвучку

"sleeper" 		Схема спящего NPC

"kamp"			Схема сталкера, сидящего в определенном радиусе вокруг указанной точки (чаще у костра), и располагающегося лицом к этой точке

"camper" 		Кампер стоит на точке и смотрит в направлении, куда Вы его поставили в редакторе или передвигается по патрульным путям, камперы переключаются на универсальный комбат, только если видят врага ближе чем в 30 метрах

"heli_hunter"	Хелихантер может стрелять либо не стрелять по вертолету в зависимости от условий

"follower"		NPC идет за NPC-лидером. Если до лидера расстояние менее 5 метров, то он идет, если от 5 до 20 – бежит в режиме run, если свыше 20 – догоняет в режиме sprint. Пути не задаются

"wounded"		Схема раненного. Определяет поведение NPC в состоянии "раненный"

"patrol" 		Итак, есть предварительная система патруля. Представляет собой вариацию kamp только в состоянии ходьбы

----------------------------------------------------------------------
Схемы для мутантов:
----------------------------------------------------------------------
"mob_remark" 	  Ремарковая схема, только не для сталкеров, а для монстров.

"mob_walker"	  Работает аналогично схеме обычного walker. Но есть некоторые отличия.

"mob_eluder"	  Монстр перемещается по точкам патрульного пути (не учитывая связи между точками), держась на расстоянии от игрока, при этом придерживаясь своего пути, выходя из под схемы при слишком близком приближении к игроку, и возвращаясь обратно, когда расстояние увеличиться.

"mob_jump"		  Схема mob_jump служит для задания прыжков монстров без каких либо проверок и ограничений (расстояние, углы и т.д.). Указывается позиция с помощью патрульного пути, смещение относительно этой позиции и физический фактор прыжка.

"mob_camp"		  Свойства схемы:
						Сидит на позиции, смотрит в точку;
						Можно задать несколько позиций и время смены позиции;
						Перемещается между позициями бегом;
						При виде врага переходит под универсальную схему (комбат/паника и т.д);
						Задаются минимальная и максимальная дистанции от врага до текущей camp-позиции;
						Если враг уходит далеко - монстр возвращается на позицию;
						
"mob_home"		  Схема является ещё одним решением по замене рестрикторов. Рекомендую все следующие гулаги монстров делать на mob_home, а старые гулаги постепенно переводить на mob_home. У кого рестрикторы работают хорошо и красиво, их можно не трогать.

"mob_fake_death" Появилась схема mob_fake_death для зомби. Необходимо для сценок, когда игрок идёт, а вокруг него начинают подниматься зомби.

----------------------------------------------------------------------
Схемы физических объектов:
----------------------------------------------------------------------
"ph_door"
"ph_gate"
"ph_idle"
"ph_hit"
"ph_on_hit"
"ph_impulse"
"ph_camera"
"ph_car"
"ph_button"
"ph_code"
"ph_sound"
"ph_force"
"ph_on_death"
"ph_oscillate"
"fx_sound"

----------------------------------------------------------------------
Схема вертолёта:
----------------------------------------------------------------------
"heli_move"

----------------------------------------------------------------------
Схемы рестрикторов:
----------------------------------------------------------------------
"sr_no_weapon"
"sr_tip"
"sr_teleport"
"sr_sound"
"sr_idle"
"sr_territory"
"sr_danger"
"sr_light"
"sr_particle"
"sr_mapspot"
"sr_sound_act"
"sr_timer"
"sr_psy_antenna"
"sr_postprocess"
"sr_aes_deadzone"
"sr_sleep"
"sr_cutscene"

--------------------------------------------------------------------------
Ещё есть такая подсказка
--------------------------------------------------------------------------
on_actor_dist_le = <number>|<название_схемы> - если дистанция в метрах до игрока меньше либо равно number.
on_actor_dist_le_nvis = <number>|<название_схемы> - если дистанция в метрах до игрока меньше либо равно number без проверки на видимость.
on_actor_dist_ge = <number>|<название_схемы> - если дистанция в метрах до игрока больше number.
on_actor_dist_ge_nvis = <number>|<название_схемы> - если дистанция в метрах до игрока больше number без проверки на видимость.
on_signal = <имя_сигнала>|<название_схемы> - срабатывает по приходу сигнала имя_сигнала от текущей активной схемы.
on_info = <название_схемы> - срабатывает всегда.
on_timer = <number>|<название_схемы> - срабатывает через number миллисекунд после включения схемы.
on_game_timer = <number>|<название_схемы> – срабатывает через number секунд игрового времени, после включения схемы.
on_actor_in_zone = <имя_зоны>|<название_схемы> – если актер в находится в указанной зоне (указывается имя рестриктора).
on_actor_not_in_zone = <имя_зоны>|<название_схемы> – если актер не в указанной зоне (указывается имя рестриктора).
on_npc_in_zone = <number>|<имя_зоны>|<название_схемы> – если NPC со story_id равному number, в указанной зоне.
on_npc_not_in_zone = <number>|<имя_зоны>|<название_схемы> - если NPC со story_id равному number, не в указанной зоне.
on_actor_inside = <название_схемы> - зона проверяет, находится ли игрок внутри нее (используется со space_restrictor).
on_actor_outside = <название_схемы> - зона проверяет, находится ли игрок за ее пределами (используется со space_restrictor).
--------------------------------------------------------------------------
Условия могут быть следующими:
+infoportion - требуется присутствие инфопорции "infoportion" у актора;
-infoportion - требуется отсутствие инфопорции "infoportion" у актора;
=function - требуется, чтобы функция "function" вернула true;
!function - требуется, чтобы функция "function" вернулся false;
~number - вероятность выполнения условия.
---------------------------------------------------------------------------
в % % происходит выполнение
в { } происходит проверка
---------------------------------------------------------------------------
Функции проверки должны лежать в \gamedata\scripts\xr_conditions.script
---------------------------------------------------------------------------
Функции типа %=% должны лежать в \gamedata\scripts\xr_effects.script
---------------------------------------------------------------------------
КАСАЕТСЯ ТОЛЬКО ВЫЗОВА ФУНКЦИЙ ТИПА %=%. По другому их вызывать нельзя, то есть: "%=имя_файла.название_функции%", НО если внести некоторые правки, то можно.

Для этого нужно открыть \gamedata\scripts\xr_logic.script

и где-то с 578-й строки вместо этого:

		if infop_conditions_met then
			-- Условия выполнены. Независимо от того, задана ли секция, нужно проставить требуемые
			-- infoportions:
			for inum, infop in pairs(cond.infop_set) do
				if db.actor == nil then
					abort("TRYING TO SET INFOS THEN ACTOR IS NIL")
				end
				if infop.func then
					if not xr_effects[infop.func] then
						abort("object '%s': pick_section_from_condlist: function '%s' is " ..
							"not defined in xr_effects.script", if_then_else(npc, npc:name(), "nil"), infop.func)
					end
					if infop.params then
						xr_effects[infop.func](actor, npc, infop.params)
					else
						xr_effects[infop.func](actor, npc)
					end
				elseif infop.required then
					if not has_alife_info(infop.name) then
						actor:give_info_portion(infop.name)
					end
				else
					if has_alife_info(infop.name) then
						actor:disable_info_portion(infop.name)
					end
				end
			end
			if cond.section == "never" then
				return nil
			else
				return cond.section
			end
		end
	end

	--printf("_bp: pick_section_from_condlist: nil")
	return nil
end

Надо написать вот это:
		if infop_conditions_met then
			-- Условия выполнены. Независимо от того, задана ли секция, нужно проставить требуемые
			-- infoportions:
			for inum, infop in pairs(cond.infop_set) do
				if db.actor == nil then
					abort("TRYING TO SET INFOS THEN ACTOR IS NIL")
				end
				if infop.func then
					local func=nil
					local module,fname=string.match(infop.func,"(.+)[.](.+)")
    
				if not fname then
					func=xr_effects[infop.func]
				elseif _G[module] and _G[module][fname] then
					func=_G[module][fname]
				end
    
				if not func then
					abort("object '%s': pick_section_from_condlist: function '%s' is " ..
					"not defined in xr_effects.script", iif(npc, npc:name(), "nil"), infop.func)
				end

				if infop.params then
					func(db.actor, npc, infop.params)
				else
					func(db.actor, npc)
				end

				elseif infop.required then
				if not has_alife_info(infop.name) then
				   actor:give_info_portion(infop.name)
				end
				else
				if has_alife_info(infop.name) then
				   actor:disable_info_portion(infop.name)
				end
			end
		end
			if cond.section == "never" then
				return nil
			else
				return cond.section
			end
		end
	end

	-- printf("_bp: pick_section_from_condlist: nil")
	return nil
end